% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantile_ensemble.R
\name{quantile_ensemble}
\alias{quantile_ensemble}
\title{Quantile ensemble}
\usage{
quantile_ensemble(qarr, y, tau, weights = NULL, tau_groups = rep(1,
  length(tau)), intercept = FALSE, nonneg = TRUE, unit_sum = TRUE,
  noncross = TRUE, q0 = NULL, lp_solver = "gurobi",
  time_limit = NULL, params = list(), verbose = FALSE)
}
\arguments{
\item{qarr}{Array of predicted quantiles, of dimension (number of prediction 
points) x (number or ensemble components) x (number of quantile levels).}

\item{y}{Vector of responses (whose quantiles are being predicted by
\code{qarr}).}

\item{tau}{Vector of quantile levels at which predictions are made.}

\item{weights}{Vector of observation weights (to be used in the loss
function). Default is NULL, which is interpreted as a weight of 1 for each
observation.}

\item{tau_groups}{Vector of group labels, having the same length as
\code{tau}. Common labels indicate that the ensemble weights for the
corresponding quantile levels should be tied together. Default is 
\code{rep(1,length(tau))}, which means that a common set of ensemble
weights should be used across all levels. See details.}

\item{intercept}{Should an intercept be included in the ensemble model?
Default is FALSE.}

\item{nonneg}{Should the ensemble weights be constrained to be nonnegative?
Default is TRUE.}

\item{unit_sum}{Should the ensemble weights be constrained to sum to 1?
Default is TRUE.}

\item{noncross}{Should noncrossing constraints be enforced? Default is
TRUE. Note: this option only matters when there is more than group of
ensemble weights, as determined by \code{tau_groups}. See details.}

\item{q0}{Array of points used to define the noncrossing
constraints. Must haev dimension (number of points) x (number of ensemble
components) x (number of quantile levels). Default is NULL, which means
that we consider noncrossing constraints at the training points
\code{qarr}.}

\item{lp_solver}{One of "gurobi" or "glpk", indicating which LP solver to
use. Default is "gurobi".}

\item{time_limit}{This sets the maximum amount of time (in seconds) to allow
Gurobi or GLPK to solve any single quantile generalized lasso problem (for
a single tau and lambda value). Default is NULL, which means unlimited
time.}

\item{params}{A list of control parameters to pass to Gurobi or GLPK. Default
is \code{list()} which means no additional parameters are passed. For
example: with Gurobi, we can use \code{list(Threads=4)} to specify that  
Gurobi should use 4 threads when available. (Note that if a time limit is
specified through this \code{params} list, then its value will be overriden 
by the last argument \code{time_limit}, assuming the latter is not NULL.)}

\item{verbose}{Should progress be printed out to the console? Default is
FALSE.}
}
\value{
A list with the following components:
  \itemize{
  \item alpha: vector or matrix of ensemble weights. If \code{tau_groups} has
  only one unique label, then this is a vector of length = (number of
  ensemble components); otherwise, it is a matrix, of dimension (number of
  ensemble components) x (number of quantile levels)
  \item tau: vector of quantile levels used
  \item weights, tau_groups, ..., params: values of these other arguments
  used in the function call  
  }
}
\description{
Fit ensemble weights, given a set of quantile predictions.
}
\details{
This function solves the following quantile ensemble optimization
  problem, over quantile levels \eqn{\tau_k, k=1,\ldots,r}:
  \deqn{\mathop{\mathrm{minimize}}_{\alpha_j, j=1,\ldots,p} \; \sum_{k=1}^r 
  \sum_{i=1}^n w_i \psi_{\tau_k} \bigg(y_i - \sum_{j=1}^p \alpha_j q_{ijk}
  \bigg)} \deqn{\mathrm{subject \; to} \;\; \sum_{j=1}^p \alpha_j = 1, \; 
  \alpha_j \geq 0, \; j=1,\ldots,p}
  for a response vector \eqn{y} and quantile array \eqn{q}, where
  \eqn{q_{ijk}} is an estimate of the quantile of \eqn{y_i} at the level
  \eqn{\tau_k}, from ensemble component member \eqn{j}. Here
  \eqn{\psi_\tau(v) = \max\{\tau v, (\tau-1) v\}} is the "pinball" or "tilted
  \eqn{\ell_1}" loss. A more advanced version allows us to estimate a
  separate ensemble weight \eqn{\alpha_{jk}} per component method \eqn{j},
  per quantile level \eqn{k}: 
  \deqn{\mathop{\mathrm{minimize}}{\alpha_{jk}, j=1,\ldots,p, k=1,\ldots,r} 
  \; \sum_{k=1}^r \sum_{i=1}^n w_i \psi_{\tau_k} \bigg(y_i - \sum_{j=1}^p
  \alpha_{jk} q_{ijk} \bigg)} \deqn{\mathrm{subject \; to} \;\; 
  \sum_{j=1}^p \alpha_{jk} = 1, \; k=1,\ldots,r, \; 
  \alpha_{jk} \geq 0, \; j=1,\ldots,p, \; k=1,\ldots,r}
  As a form of regularization, we can additionally incorporate noncrossing
  constraints into the above optimization, which take the form:
  \deqn{\alpha_{\bullet,k}^T q \leq \alpha_{\bullet,k+1}^T q, \;
  k=1,\ldots,r-1, \; q \in \mathcal{Q}}
  where the quantile levels \eqn{\tau_k, k=1,\ldots,r} are assumed to be in
  increasing order, and \eqn{\mathcal{Q}} is a collection of points over
  which to enforce the noncrossing constraints. Finally, somewhere in between
  these two extremes is to allow one ensemble weight per component member
  \eqn{j}, per quantile group \eqn{g}. This can be interpreted as a set of
  further constraints which enforce equality between \eqn{\alpha_{jk}} and
  \eqn{\alpha_{j\ell}}, for all \eqn{k,\ell} that are in the same group
  \eqn{g}.
}
