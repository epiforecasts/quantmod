document()
obj5 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=c(rep(1,5),rep(2,10),rep(3,8)))
obj5$alpha
# Set up the problem
x = seq(0,5,length=1000)
m1 = 1; s1 = 0.25
m2 = 3; s2 = 0.5
m0 = 2.25; s0 = 1
set.seed(11)
n = 5
m1_vec = m1 + runif(n+1,-0.2,0.2)
s1_vec = s1 + runif(n+1,-0.1,0.1)
m2_vec = m2 + runif(n+1,-0.2,0.2)
s2_vec = s2 + runif(n+1,-0.1,0.1)
ylim = c(0,1/(sqrt(2*pi)*min(s1_vec,s2_vec)))
plot(x, dnorm(x,m0,s0), type="l", lty=1, ylim=ylim, ylab="Density")
for (i in 1:n) {
lines(x, dnorm(x,m1_vec[i],s1_vec[i]), col="pink", lwd=0.5)
lines(x, dnorm(x,m2_vec[i],s2_vec[i]), col="lightblue", lwd=0.5)
}
tau = c(0.1,0.5,0.9)
r = length(tau); m = 2
Q = array(NA, dim=c(n+1,m,r))
for (i in 1:(n+1)) {
Q[i,1,] = qnorm(tau,m1_vec[i],s1_vec[i])
Q[i,2,] = qnorm(tau,m2_vec[i],s2_vec[i])
}
# Get n true draws
z = rnorm(n,m0,s0)
# Standard quantile stacking (do not need to pass the test predictions)
out_stan = quantile_stacking_standard(Q[-(n+1),,], z, tau)
out_stan$alpha
load_all("quantmod")
# Standard quantile stacking (do not need to pass the test predictions)
out_stan = quantile_stacking_standard(Q[-(n+1),,], z, tau)
out_stan$alpha
obj1 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi")
obj2 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="glpk")
out_stan$alpha
obj1$alpha
obj2$alpha
# Flexible quantile stacking (we need to pass the test predictions)
out_flex = quantile_stacking_flexible(Q, z, tau)
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
obj3 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=1:r)
obj4 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="glpk", tau_groups=1:r)
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
points(tau, obj3$alpha[1,], type="o", col=2, cex=2)
points(tau, obj4$alpha[1,], type="o", col=3, cex=3)
obj5 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=c(1,1,2))
obj5$alpha
document()
obj5 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=c(1,1,2))
nrowA
A
model$A
model$A
ind
nrowA + (k-1)*p + 1:p
(0:(p-1))*r + ind[k]
(0:(p-1))*r + ind[k+1]
nrowA
nrow(model$A)
nrowA
model$A
k=1
ind[k]
ind
ind=c(1,2)
ind
ind[k]
document()
obj5 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=c(1,1,2))
model$A
ind=c(1,2)
0:(p-1))*ind[k] + 1:p
(ind[k]-1)*p + 1:p
(ind[k+1]-1)*p + 1:p
document()
obj5 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=c(1,1,2))
model$A
document()
obj5 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=c(1,1,2))
obj5$alpha
# Set up the problem
x = seq(0,5,length=1000)
m1 = 1; s1 = 0.25
m2 = 3; s2 = 0.5
m0 = 2.25; s0 = 1
set.seed(11)
n = 50
m1_vec = m1 + runif(n+1,-0.2,0.2)
s1_vec = s1 + runif(n+1,-0.1,0.1)
m2_vec = m2 + runif(n+1,-0.2,0.2)
s2_vec = s2 + runif(n+1,-0.1,0.1)
ylim = c(0,1/(sqrt(2*pi)*min(s1_vec,s2_vec)))
plot(x, dnorm(x,m0,s0), type="l", lty=1, ylim=ylim, ylab="Density")
for (i in 1:n) {
lines(x, dnorm(x,m1_vec[i],s1_vec[i]), col="pink", lwd=0.5)
lines(x, dnorm(x,m2_vec[i],s2_vec[i]), col="lightblue", lwd=0.5)
}
# Get n quantile forecasts, from each forecaster
tau = c(0.01, 0.025, seq(0.05, 0.95, by=0.05), 0.975, 0.99)
r = length(tau); m = 2
Q = array(NA, dim=c(n+1,m,r))
for (i in 1:(n+1)) {
Q[i,1,] = qnorm(tau,m1_vec[i],s1_vec[i])
Q[i,2,] = qnorm(tau,m2_vec[i],s2_vec[i])
}
# Get n true draws
z = rnorm(n,m0,s0)
# Standard quantile stacking (do not need to pass the test predictions)
out_stan = quantile_stacking_standard(Q[-(n+1),,], z, tau)
out_stan$alpha
load_all("quantmod")
obj1 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi")
obj2 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="glpk")
out_stan$alpha
obj1$alpha
obj2$alpha
# Flexible quantile stacking (we need to pass the test predictions)
out_flex = quantile_stacking_flexible(Q, z, tau)
# Flexible quantile stacking (we need to pass the test predictions)
out_flex = quantile_stacking_flexible(Q, z, tau)
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
obj3 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=1:r)
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
points(tau, obj3$alpha[1,], type="o", col=2, cex=2)
points(tau, obj4$alpha[1,], type="o", col=3, cex=3)
obj3 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=1:r)
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
points(tau, obj3$alpha[1,], type="o", col=2, cex=2)
points(tau, obj4$alpha[1,], type="o", col=3, cex=3)
obj3$alpha
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
points(tau, obj3$alpha[1,], type="o", col=2, cex=2)
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
points(tau, obj3$alpha[1,], type="o", col=2, cex=2)
points(tau, obj4$alpha[1,], type="o", col=3, cex=3)
obj4$alpha
obj4 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="glpk", tau_groups=1:r)
points(tau, obj4$alpha[1,], type="o", col=3, cex=3)
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
points(tau, obj3$alpha[1,], type="o", col=2, cex=2)
points(tau, obj4$alpha[1,], type="o", col=3, cex=3)
obj5 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="gurobi", tau_groups=c(rep(1,5),rep(2,10),rep(3,8)))
obj6 = quantile_ensemble(Q[-(n+1),,], z, tau, lp_solver="glpk", tau_groups=c(rep(1,5),rep(2,10),rep(3,8)))
plot(tau, out_flex$alpha[1,], type="o", ylab="alpha")
points(tau, obj3$alpha[1,], type="o", col=2, cex=2)
points(tau, obj4$alpha[1,], type="o", col=3, cex=3)
points(tau, obj5$alpha[1,], type="p", col=4, pch=20)
points(tau, obj6$alpha[1,], type="p", col=5, pch=20, cex=0.5)
library(quantmod)
library(glmnet)
n = 500
p = 50
x = matrix(rnorm(n*p), n, p)
mu = function(x) x[1] + x[2]
y = rpois(n, exp(apply(x, 1, mu)))
# Run CV for quantile lasso
tau = c(0.1, 0.3, 0.5, 0.7, 0.9)
cv_obj1 = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE)
cv_obj2 = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE,
transform=log_pad(a=1), inv_trans=inv_log_pad(a=1), jitter=unif_jitter())
plot(cv_obj1)
plot(cv_obj2)
# Run CV Poisson lasso
cv_obj3 = cv.glmnet(x, y, family="poisson", nlambda=30, nfolds=5)
# Generate test data
n0 = 100
x0 = matrix(rnorm(n0*p), n0, p)
plot(cv_obj3)
# Generate test data
n0 = 100
x0 = matrix(rnorm(n0*p), n0, p)
y0 = rpois(n0, exp(apply(x0, 1, mu)))
# Predicted quantiles at test points
tau_new = c(0.01, 0.025, seq(0.05, 0.95, by=0.05), 0.975, 0.99)
qpred1_init = predict(cv_obj1, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
qpred1 = quantile_extrapolate(tau, qpred1_init, tau_new, qfun_left=qpois, qfun_right=qpois, nonneg=TRUE, round=TRUE)
qpred2_init = predict(cv_obj2, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
qpred2 = quantile_extrapolate(tau, qpred2_init, tau_new, qfun_left=qpois, qfun_right=qpois, nonneg=TRUE, round=TRUE)
qpred3 = matrix(qpois(rep(tau,each=n0), rep(exp(predict(cv_obj1, x0)), length(tau))), nrow=n0)
dim(qpred1)
dim(qpred2)
dim(qpred1_init)
qpred3 = matrix(qpois(rep(tau_new, each=n0), rep(exp(predict(cv_obj1, x0)), length(tau_new))), nrow=n0)
qarr = array(NA, dim=c(n0,3,length(tau_new)))
qarr[,1,] = qpred1
qarr[,2,] = qpred2
qarr[,3,] = qpred3
dim(qpred3)
qpred3 = matrix(qpois(rep(tau_new, each=n0), rep(exp(predict(cv_obj3, x0)), length(tau_new))), nrow=n0)
qarr[,3,] = qpred3
23-6
# Standard stacking: one weight per ensemble member
st_obj1 = quantile_ensemble(qarr, y0, tau_new, verbose=TRUE)
# Flexible stacking: one weight per ensemble member, per quantile level
st_obj2 = quantile_ensemble(qarr, y0, tau_new, tau_groups=1:length(tau_new), verbose=TRUE)
# Somewhere in the middle: group the extreme 3 quantiles together on either tail, and the middle
st_obj3 = quantile_ensemble(qarr, y0, tau_new, tau_groups=c(rep(1,3),rep(2,17),rep(3,3)), verbose=TRUE)
st_obj$alpha
st_obj1$alpha
st_obj2$alpha
st_obj3$alpha
obj3 = refit_quantile_lasso(cv_obj1, x, y, tau_new)
obj4 = refit_quantile_lasso(cv_obj2, x, y, tau_new, verbose=TRUE)
qpred3 = predict(obj3, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
qpred4 = predict(obj4, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
dim(qpred3)
dim(qpred4)
qarr = array(NA, dim=c(n0,4,length(tau_new)))
qarr[,1,] = qpred1
qarr[,2,] = qpred2
qarr[,3,] = qpred3
qarr[,4,] = qpred4
# Standard stacking: one weight per ensemble member
st_obj1 = quantile_ensemble(qarr, y0, tau_new, verbose=TRUE)
st_obj1$alpha
# Flexible stacking: one weight per ensemble member, per quantile level
st_obj2 = quantile_ensemble(qarr, y0, tau_new, tau_groups=1:length(tau_new), verbose=TRUE)
st_obj2$alpha
# Somewhere in the middle: group the extreme 3 quantiles together on either tail, and the middle
st_obj3 = quantile_ensemble(qarr, y0, tau_new, tau_groups=c(rep(1,3),rep(2,17),rep(3,3)), verbose=TRUE)
st_obj3$alpha
st_obj2$alpha
st_obj1$alpha
st_obj2$alpha
st_obj3$alpha
library(quantmod)
library(glmnet)
n = 500
p = 50
x = matrix(rnorm(n*p), n, p)
mu = function(x) x[1] + x[2]
y = rpois(n, exp(apply(x, 1, mu)))
# Run CV for quantile lasso
tau = c(0.1, 0.3, 0.5, 0.7, 0.9)
cv_obj1 = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE)
cv_obj2 = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE,
transform=log_pad(a=1), inv_trans=inv_log_pad(a=1), jitter=unif_jitter())
plot(cv_obj1)
plot(cv_obj2)
# Refit a more quantile levels
tau_new = c(0.01, 0.025, seq(0.05, 0.95, by=0.05), 0.975, 0.99)
obj3 = refit_quantile_lasso(cv_obj1, x, y, tau_new, verbose=TRUE)
obj4 = refit_quantile_lasso(cv_obj2, x, y, tau_new, verbose=TRUE)
# Generate test data
n0 = 100
x0 = matrix(rnorm(n0*p), n0, p)
y0 = rpois(n0, exp(apply(x0, 1, mu)))
# Predicted quantiles at test points
qpred1_init = predict(cv_obj1, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
qpred1 = quantile_extrapolate(tau, qpred1_init, tau_new, qfun_left=qpois, qfun_right=qpois, nonneg=TRUE, round=TRUE)
qpred2_init = predict(cv_obj2, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
qpred2 = quantile_extrapolate(tau, qpred2_init, tau_new, qfun_left=qpois, qfun_right=qpois, nonneg=TRUE, round=TRUE)
qpred3 = predict(obj3, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
qpred4 = predict(obj4, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
# Construct array of predicted quantiles
qarr = array(NA, dim=c(n0,4,length(tau_new)))
qarr[,1,] = qpred1
qarr[,2,] = qpred2
qarr[,3,] = qpred3
qarr[,4,] = qpred4
# Standard stacking: one weight per ensemble member
st_obj1 = quantile_ensemble(qarr, y0, tau_new, verbose=TRUE)
st_obj1$alpha
# Flexible stacking: one weight per ensemble member, per quantile level
st_obj2 = quantile_ensemble(qarr, y0, tau_new, tau_groups=1:length(tau_new), verbose=TRUE)
st_obj2$alpha
# Somewhere in the middle: group the extreme 3 quantiles together on either tail, and the middle
st_obj3 = quantile_ensemble(qarr, y0, tau_new, tau_groups=c(rep(1,3),rep(2,17),rep(3,3)), verbose=TRUE)
st_obj3$alpha
rt(10)
rt(10,df=2)
unif(n)
runif
runif(n)
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=3)))
hist(e,breaks=30)
mean(e)
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=3)))
hist(e,breaks=30)
hist(e,breaks=40)
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=2)))
hist(e,breaks=40)
hist(e,breaks=30)
median(e)
library(quantmod)
n = 200
p = 50
x = matrix(rnorm(n*p), n, p)
mu = function(x) x[1] + x[2]
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=3)))
y = exp(apply(x, 1, mu)) + e
# Run CV for quantile lasso
tau = c(0.1, 0.3, 0.5, 0.7, 0.9)
cv_obj = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE)
glmnet_obj = cv.glmnet(x, y, nfolds=5)
hist(e, breaks=40, col="pink", main="Error distribution")
n = 300
p = 50
x = matrix(rnorm(n*p), n, p)
mu = function(x) x[1] + x[2]
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=3)))
hist(e, breaks=40, col="pink", main="Error distribution")
n = 300
p = 50
x = matrix(rnorm(n*p), n, p)
mu = function(x) x[1] + x[2]
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=3)))
hist(e, breaks=40, col="pink", main="Error distribution")
hist(e, breaks=40, col="lightblue", main="Error distribution")
lines(density(e), lwd=c, col=4)
hist(e, breaks=40, col="lightblue", main="Error distribution")
lines(density(e), lwd=2, col=4)
hist(e, breaks=40, col="lightblue", main="Error distribution", prob=TRUE)
lines(density(e), lwd=2)
# Run CV for quantile lasso
tau = c(0.1, 0.3, 0.5, 0.7, 0.9)
cv_obj = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE)
library(quantmod)
n = 300
p = 50
x = matrix(rnorm(n*p), n, p)
mu = function(x) x[1] + x[2]
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=3)))
y = exp(apply(x, 1, mu)) + e
# Histogram of error distribution: skewed, and heavy-tailed on one side
hist(e, breaks=40, col="lightblue", main="Error distribution", prob=TRUE)
lines(density(e), lwd=2)
# Run CV for quantile lasso
tau = c(0.1, 0.3, 0.5, 0.7, 0.9)
cv_obj = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE)
glmnet_obj = cv.glmnet(x, y, nfolds=5)
glmnet_obj = cv.glmnet(x, y, nfolds=5, verbose=TRUE)
quant_obj = cv_obj
quant_obj = cv_obj
plot(quant_obj)
plot(glmnet_obj)
plot(quant_obj)
tau_new = c(0.01, 0.025, seq(0.05, 0.95, by=0.05), 0.975, 0.99)
refit_obj = refit_quantile_lasso(cv_obj, x, y, tau_new, verbose=TRUE)
qpred1_init = predict(quant_obj, x0, sort=TRUE, nonneg=TRUE, round=TRUE)
qpred1 = quantile_extrapolate(tau, qpred1_init, tau_new, qfun_left=qnorm, qfun_right=qnorm, nonneg=TRUE, round=TRUE)
n0 = 100
x0 = matrix(rnorm(n0*p), n0, p)
e0 = ifelse(runif(n0) < 0.5, -abs(rnorm(n0)), abs(rt(n0, df=3)))
y0 = exp(apply(x0, 1, mu)) + e0
qpred2_init = predict(quant_obj, x0, sort=TRUE)
qpred2 = quantile_extrapolate(tau, qpred2_init, tau_new, qfun_left=qnorm, qfun_right=qnorm)
library(quantmod)
n = 300
p = 50
x = matrix(rnorm(n*p), n, p)
mu = function(x) x[1] + x[2]
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=3)))
y = apply(x, 1, mu) + e
# Histogram of error distribution: skewed, and heavy-tailed on one side
hist(e, breaks=40, col="lightblue", main="Error distribution", prob=TRUE)
lines(density(e), lwd=2)
tau = c(0.1, 0.3, 0.5, 0.7, 0.9)
glmnet_obj = cv.glmnet(x, y, nfolds=5)
quant_obj = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE)
plot(glmnet_obj)
plot(quant_obj)
# Predicted quantiles at test points
qtrue_fun = function(prob) ifelse(prob < 0.5, qnorm(prob), qt(prob, df=3))
outer(1:5, 2:6, "+")
qpred2_init = predict(quant_obj, x0, sort=TRUE)
qpred2 = quantile_extrapolate(tau, qpred2_init, tau_new, qfun_left=qnorm, qfun_right=qnorm)
dim(qpred2)
# Predicted quantiles at test points
qtrue = outer(apply(x0, 1, mu), ifelse(prob < 0.5, qnorm(tau_new), qt(tau_new, df=3)), "+")
qtrue = outer(apply(x0, 1, mu), ifelse(tau_new < 0.5, qnorm(tau_new), qt(tau_new, df=3)), "+")
dim(qtrue)
predict(glmnet_obj, x0)
qtrue = outer(apply(x0, 1, mu), ifelse(tau_new < 0.5, qnorm(tau_new), qt(tau_new, df=3)), "+")
qpred1 = outer(predict(glmnet_obj, x0), qnorm(tau_new), "+")
qpred2_init = predict(quant_obj, x0, sort=TRUE)
qpred2 = quantile_extrapolate(tau, qpred2_init, tau_new, qfun_left=qnorm, qfun_right=qnorm)
qpred3 = predict(refit_obj, x0, sort=TRUE)
par(mfrow=c(1,3))
for (i in 1:9) {
plot(tau_new, qtrue, type="o", ylim=range(qtrue, qpred1, qpred2, qpred3), ylab="Quantile")
lines(tau_new, qpred1, col=2, pch=20, type="o")
lines(tau_new, qpred2, col=3, pch=20, type="o")
lines(tau_new, qpred3, col=4, pch=20, type="o")
legend("topleft", legend=c("True", "Lasso", "QLasso (extrap)", "QLasso (refit)"),
col=1:4, pch=c(21,20,20,20))
}
par(mfrow=c(1,3))
for (i in 1:9) {
plot(tau_new, qtrue[i,], type="o", ylim=range(qtrue, qpred1, qpred2, qpred3), ylab="Quantile")
lines(tau_new, qpred1[i,], col=2, pch=20, type="o")
lines(tau_new, qpred2[i,], col=3, pch=20, type="o")
lines(tau_new, qpred3[i,], col=4, pch=20, type="o")
legend("topleft", legend=c("True", "Lasso", "QLasso (extrap)", "QLasso (refit)"),
col=1:4, pch=c(21,20,20,20))
}
dim(qpred1)
# Predicted quantiles at test points
qtrue = outer(apply(x0, 1, mu), ifelse(tau_new < 0.5, qnorm(tau_new), qt(tau_new, df=3)), "+")
qpred1 = outer(as.numeric(predict(glmnet_obj, x0)), qnorm(tau_new), "+")
qpred2_init = predict(quant_obj, x0, sort=TRUE)
qpred2 = quantile_extrapolate(tau, qpred2_init, tau_new, qfun_left=qnorm, qfun_right=qnorm)
qpred3 = predict(refit_obj, x0, sort=TRUE)
par(mfrow=c(1,3))
for (i in 1:9) {
plot(tau_new, qtrue[i,], type="o", ylim=range(qtrue, qpred1, qpred2, qpred3), ylab="Quantile")
lines(tau_new, qpred1[i,], col=2, pch=20, type="o")
lines(tau_new, qpred2[i,], col=3, pch=20, type="o")
lines(tau_new, qpred3[i,], col=4, pch=20, type="o")
legend("topleft", legend=c("True", "Lasso", "QLasso (extrap)", "QLasso (refit)"),
col=1:4, pch=c(21,20,20,20))
}
par(mfrow=c(1,3))
for (i in 1:9) {
plot(tau_new, qtrue[i,], type="o", ylim=range(qtrue, qpred1, qpred2, qpred3), ylab="Quantile")
lines(tau_new, qpred1[i,], col=2, pch=20, type="o")
lines(tau_new, qpred2[i,], col=3, pch=20, type="o")
lines(tau_new, qpred3[i,], col=4, pch=20, type="o")
legend("topleft", legend=c("True", "Lasso", "QLasso (extrap)", "QLasso (refit)"),
col=1:4, pch=c(21,20,20,20))
}
# Refit quantile lasso at more quantile levels
tau_new = c(0.01, 0.025, seq(0.05, 0.95, by=0.05), 0.975, 0.99)
refit_obj = refit_quantile_lasso(quant_obj, x, y, tau_new, verbose=TRUE)
# Predicted quantiles at test points
qtrue = outer(apply(x0, 1, mu), ifelse(tau_new < 0.5, qnorm(tau_new), qt(tau_new, df=3)), "+")
qpred1 = outer(as.numeric(predict(glmnet_obj, x0)), qnorm(tau_new), "+")
qpred2_init = predict(quant_obj, x0, sort=TRUE)
qpred2 = quantile_extrapolate(tau, qpred2_init, tau_new, qfun_left=qnorm, qfun_right=qnorm)
qpred3 = predict(refit_obj, x0, sort=TRUE)
par(mfrow=c(1,3))
for (i in 1:9) {
plot(tau_new, qtrue[i,], type="o", ylim=range(qtrue, qpred1, qpred2, qpred3), ylab="Quantile")
lines(tau_new, qpred1[i,], col=2, pch=20, type="o")
lines(tau_new, qpred2[i,], col=3, pch=20, type="o")
lines(tau_new, qpred3[i,], col=4, pch=20, type="o")
legend("topleft", legend=c("True", "Lasso", "QLasso (extrap)", "QLasso (refit)"),
col=1:4, pch=c(21,20,20,20))
}
# Construct array of predicted quantiles
qarr = array(NA, dim=c(n0,3,length(tau_new)))
qarr[,1,] = qpred1
qarr[,2,] = qpred2
qarr[,3,] = qpred3
# Standard stacking: one weight per ensemble member
st_obj1 = quantile_ensemble(qarr, y0, tau_new, verbose=TRUE)
st_obj1$alpha
# Flexible stacking: one weight per ensemble member, per quantile level
st_obj2 = quantile_ensemble(qarr, y0, tau_new, tau_groups=1:length(tau_new), verbose=TRUE)
st_obj2$alpha
# Somewhere in the middle: group the extreme 3 quantiles together on either tail, and the middle
st_obj3 = quantile_ensemble(qarr, y0, tau_new, tau_groups=c(rep(1,3),rep(2,17),rep(3,3)), verbose=TRUE)
st_obj3$alpha
library(quantmod)
set.seed(0)
n = 300
p = 50
x = matrix(rnorm(n*p), n, p)
mu = function(x) x[1] + x[2]
e = ifelse(runif(n) < 0.5, -abs(rnorm(n)), abs(rt(n, df=3)))
y = apply(x, 1, mu) + e
# Histogram of error distribution: skewed, and heavy-tailed on one side
hist(e, breaks=40, col="lightblue", main="Error distribution", prob=TRUE)
lines(density(e), lwd=2)
# Run CV for usual lasso, and quantile lasso
tau = c(0.1, 0.3, 0.5, 0.7, 0.9)
glmnet_obj = cv.glmnet(x, y, nfolds=5)
quant_obj = cv_quantile_lasso(x, y, tau=tau, nlambda=30, nfolds=5, verbose=TRUE, sort=TRUE)
plot(glmnet_obj)
plot(quant_obj)
# Refit quantile lasso at more quantile levels
tau_new = c(0.01, 0.025, seq(0.05, 0.95, by=0.05), 0.975, 0.99)
refit_obj = refit_quantile_lasso(quant_obj, x, y, tau_new, verbose=TRUE)
# Generate test data
n0 = 100
x0 = matrix(rnorm(n0*p), n0, p)
e0 = ifelse(runif(n0) < 0.5, -abs(rnorm(n0)), abs(rt(n0, df=3)))
y0 = apply(x0, 1, mu) + e0
# Predicted quantiles at test points
qtrue = outer(apply(x0, 1, mu), ifelse(tau_new < 0.5, qnorm(tau_new), qt(tau_new, df=3)), "+")
qpred1 = outer(as.numeric(predict(glmnet_obj, x0)), qnorm(tau_new), "+")
qpred2_init = predict(quant_obj, x0, sort=TRUE)
qpred2 = quantile_extrapolate(tau, qpred2_init, tau_new, qfun_left=qnorm, qfun_right=qnorm)
qpred3 = predict(refit_obj, x0, sort=TRUE)
par(mfrow=c(1,3))
for (i in 1:9) {
plot(tau_new, qtrue[i,], type="o", ylim=range(qtrue, qpred1, qpred2, qpred3), ylab="Quantile")
lines(tau_new, qpred1[i,], col=2, pch=20, type="o")
lines(tau_new, qpred2[i,], col=3, pch=20, type="o")
lines(tau_new, qpred3[i,], col=4, pch=20, type="o")
legend("topleft", legend=c("True", "Lasso", "QLasso (extrap)", "QLasso (refit)"),
col=1:4, pch=c(21,20,20,20))
}
# Construct array of predicted quantiles
qarr = array(NA, dim=c(n0,3,length(tau_new)))
qarr[,1,] = qpred1
qarr[,2,] = qpred2
qarr[,3,] = qpred3
# Standard stacking: one weight per ensemble member
st_obj1 = quantile_ensemble(qarr, y0, tau_new, verbose=TRUE)
st_obj1$alpha
# Flexible stacking: one weight per ensemble member, per quantile level
st_obj2 = quantile_ensemble(qarr, y0, tau_new, tau_groups=1:length(tau_new), verbose=TRUE)
st_obj2$alpha
# Somewhere in the middle: group the extreme 3 quantiles together on either tail, and the middle
st_obj3 = quantile_ensemble(qarr, y0, tau_new, tau_groups=c(rep(1,3),rep(2,17),rep(3,3)), verbose=TRUE)
st_obj3$alpha
