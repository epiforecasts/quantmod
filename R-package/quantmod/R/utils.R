# Seq function

Seq = function(a,b) {
  if (a<=b) return(a:b)
  else return(integer(0))
}

# max.row function

max.row = function(m, ties.method=c("random", "first", "last")) {
  return(max.col(t(m), ties.method))
}

# Quiet function

quiet = function(x) {
  sink(tempfile())
  on.exit(sink())
  invisible(force(x))
}

# Enlist function

enlist = function(...) {
  result = list(...)
  if ((nargs() == 1) & is.character(n <- result[[1]])) {
    result = as.list(seq(n))
    names(result) = n
    for (i in n) result[[i]] = get(i)
  }
  else {
    n = sys.call()
    n = as.character(n)[-1]
    if (!is.null(n2 <- names(result))) {
      which = n2 != ""
      n[which] = n2[which]
    }
    names(result) = n
  }
  return(result)
}

#' Quantile loss
#'
#' Compute the quantile (tilted absolute) loss for a single tau value. 
#'
#' @export

quantile_loss = function(yhat, y, tau) {
  yhat = matrix(yhat, nrow=length(y))
  return(colSums(pmax(tau*(y-yhat), (tau-1)*(y-yhat))))
}

#' Convenience functions for log padding
#'
#' Functions to map \eqn{y \mapsto \log(a+y)} and \eqn{x \mapsto \exp(x)-a}.   
#'
#' @export

log_pad = function(a=1) function(y) log(a+y)

#' @rdname log_pad 
#' @export
inv_log_pad = function(a=1) function(x) exp(x)-a

#' Convenience function for uniform jitter
#'
#' Function to generate random draws from \eqn{\mathrm{Unif}[a,b]}.
#'
#' @export

unif_jitter = function(a=0, b=0.01) function(n) runif(n,a,b)

#' Difference matrix
#'
#' Construct a difference operator, of a given order, for use in trend filtering  
#' penalties.  
#'
#' @param p Dimension (number of columns) of the difference matrix.
#' @param k Order of the difference matrix.
#'
#' @return A sparse matrix of dimension (p - k) x p.
#'
#' @export

get_diff_mat = function(p, k) {
  I = Diagonal(p)
  D = bandSparse(p, k=c(-1,0), diag=list(rep(-1,p-1), rep(1,p)))
  B = I
  for (i in Seq(1,k)) {
    B = bdiag(I[Seq(1,i-1),Seq(1,i-1)], D[1:(p-i+1),1:(p-i+1)]) %*% B
  }
  return(B[-Seq(1,k),])
}
